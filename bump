#!/usr/bin/env python3
from argparse import ArgumentParser
from pathlib import Path
import re
import subprocess


def get_latest_build_number(version: str, tags: list[str]) -> int:
    latest_tag_number = 0
    for tag in tags:
        match = re.match(rf"^v{version}-(\d+)$", tag)
        if match:
            number = int(match.group(1))
            if number > latest_tag_number:
                latest_tag_number = number

    return latest_tag_number


def make_tag_names(version: str, build_number: int) -> list[str]:
    """Create tag names based on version number and build number.

    Given version 6.7.2 and build number 1, this will generate:
    - v6.7.2-1
    - v6.7.2
    - v6.7

    v6 will not be generated as it is the branch name
    """
    parts = version.split(".")
    return [f"v{version}-{build_number}"] + [
        "v" + ".".join(parts[: i + 1]) for i in range(1, len(parts))
    ]


def bump_version(version: str | None = None) -> None:
    workflow_path = Path(__file__).parent / ".github" / "workflows" / "build.yml"
    action_path = Path(__file__).parent /"action.yml"

    with workflow_path.open() as f:
        workflow_content = f.read()
    match = re.search(r"QT_VERSION: ([\d.]+)", workflow_content)
    if match is None:
        print("Failed to extract Qt version.")
        return
    workflow_version = match[1]
    if workflow_version == version:
        print("The old version is the same as the new version!")
        return

    with action_path.open() as f:
        action_content = f.read()
    match = re.search(r"VERSION_TAG: ([\d.]+)", action_content)
    if match is None:
        print("action.yml is malformed.")
        return
    action_version=match[1]
    if action_version != workflow_version:
        print(f"Workflow and action not match: {workflow_version} vs {action_version}")
        return

    old_tags = subprocess.run(
        ["git", "tag"], stdout=subprocess.PIPE, encoding="utf-8"
    ).stdout.splitlines()
    if version is None:
        build_number = get_latest_build_number(workflow_version, old_tags) + 1
        tag_names = make_tag_names(workflow_version, build_number)
    else:
        tag_names = make_tag_names(version, 1)
        with workflow_path.open("w") as f:
            f.write(workflow_content.replace(workflow_version, version))
    with action_path.open("w") as f:
        f.write(re.sub(r"VERSION_TAG: [\d.-]+", f"VERSION_TAG: {tag_names[0]}", action_content))
    subprocess.run(
        ["git", "commit", "-a", "--allow-empty", "-m", f"release {tag_names[0]}"]
    )
    for tag_name in tag_names:
        if tag_name in old_tags:
            subprocess.run(["git", "tag", "-d", tag_name])
        subprocess.run(["git", "tag", tag_name, "-m", tag_name])

    if input("Push [Y/n]") in ["y", "Y", ""]:
        subprocess.run(["git", "push", "--follow-tags"])
        for tag_name in tag_names:
            subprocess.run(["git", "push", "origin", tag_name, "--force"])


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("version", default=None, nargs="?")
    args = parser.parse_args()
    bump_version(args.version)
